<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS CFD: LBM D2Q9 High-Res (Stable)</title>
    <style>
        :root {
            --bg-color: #0f0f12;
            --panel-bg: rgba(20, 20, 25, 0.85);
            --text-color: #e0e0e0;
            --accent-color: #00d2ff;
            --accent-hover: #33e0ff;
            --danger-color: #ff4444;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at center, #1a1a20 0%, #000 100%);
            color: var(--text-color);
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.7);
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated; 
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            padding: 24px;
            background-color: var(--panel-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            pointer-events: auto;
            user-select: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
        }
        
        #controls:hover {
            border-color: rgba(255, 255, 255, 0.15);
        }

        h1 {
            margin: 0 0 20px 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent-color);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-group {
            margin-bottom: 18px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            font-weight: 500;
            margin-bottom: 8px;
            color: #bbb;
            letter-spacing: 0.5px;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            height: 4px;
            border-radius: 2px;
            outline: none;
            margin: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            border: 2px solid rgba(0,0,0,0.2);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #fff;
            transform: scale(1.1);
        }

        select {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }
        
        select:focus {
            border-color: var(--accent-color);
        }

        .legend {
            margin-top: 20px;
            height: 6px;
            width: 100%;
            background: linear-gradient(to right, #000080, #0000ff, #00ffff, #ffffff, #ffff00, #ff0000, #800000);
            border-radius: 3px;
            opacity: 0.8;
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: #888;
            margin-top: 6px;
            text-transform: uppercase;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.75rem;
            color: #888;
            font-family: 'Courier New', monospace;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        button#toggleBtn {
            border-color: var(--accent-color);
            color: var(--accent-color);
            background: rgba(0, 210, 255, 0.05);
        }
        
        button#toggleBtn:hover {
            background: rgba(0, 210, 255, 0.15);
        }

        button#toggleBtn.paused {
            border-color: #ffaa00;
            color: #ffaa00;
            background: rgba(255, 170, 0, 0.05);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: var(--accent-color);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>

    <canvas id="simCanvas"></canvas>
    <div class="loading" id="loading">Updating...</div>

    <div id="controls">
        <h1>
            LBM Solver
            <div style="font-size: 0.6rem; color: #666; font-weight: normal; border: 1px solid #333; padding: 2px 6px; border-radius: 4px;">D2Q9 | High Res</div>
        </h1>
        
        <div class="control-group">
            <label>Flow Speed <span id="val-speed">0.10</span></label>
            <input type="range" id="speed" min="0.01" max="0.15" step="0.001" value="0.1">
        </div>

        <div class="control-group">
            <label>Viscosity (1/Re) <span id="val-visc">0.02</span></label>
            <input type="range" id="visc" min="0.02" max="0.15" step="0.001" value="0.020">
        </div>

        <div class="control-group">
            <label>Angle of Attack <span id="val-aoa">10°</span></label>
            <input type="range" id="aoa" min="-20" max="20" step="1" value="10">
        </div>
        
        <div class="control-group">
            <label>Camber <span id="val-camber">0.1</span></label>
            <input type="range" id="camber" min="-0.5" max="0.5" step="0.01" value="0.1">
        </div>

        <div class="control-group">
            <label>Thickness <span id="val-thick">0.08</span></label>
            <input type="range" id="thick" min="0.01" max="0.3" step="0.01" value="0.08">
        </div>

        <div class="control-group">
            <label>Visualization</label>
            <select id="plotType">
                <option value="speed" selected>Velocity Magnitude</option>
                <option value="curl">Vorticity (Curl)</option>
            </select>
        </div>

        <div class="legend"></div>
        <div class="legend-labels">
            <span>Min</span>
            <span>Max</span>
        </div>

        <div class="stats-row">
            <span id="fps">FPS: 0</span>
            <span id="status">RUNNING</span>
        </div>
        
        <div class="btn-group">
            <button id="toggleBtn">Pause</button>
            <button id="resetBtn">Reset</button>
        </div>
    </div>

<script>
/**
 * OPTIMIZED JAVASCRIPT LBM CFD SOLVER
 * Fast parameter updates with background recalculation
 */

const lx = 800; 
const ly = 320; 
const totalCells = lx * ly;

const N_DIRS = 9;
const weights = new Float32Array([4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36]);
const ex = Int8Array.from([0, 1, 0, -1, 0, 1, -1, -1, 1]);
const ey = Int8Array.from([0, 0, 1, 0, -1, 1, 1, -1, -1]);
const opp = Int8Array.from([0, 3, 4, 1, 2, 7, 8, 5, 6]);

let f = new Float32Array(totalCells * N_DIRS);
let newF = new Float32Array(totalCells * N_DIRS);
let rho = new Float32Array(totalCells);
let ux = new Float32Array(totalCells);
let uy = new Float32Array(totalCells);
let barrier = new Uint8Array(totalCells);

let u0 = 0.1;       
let viscosity = 0.02;

let plotType = "speed";
let running = true;
let animationId = null;
let isUpdating = false;
let updateRequested = false;

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const imgData = ctx.createImageData(lx, ly);
const buf32 = new Uint32Array(imgData.data.buffer);
const loading = document.getElementById('loading');

const ui = {
    speed: document.getElementById('speed'),
    visc: document.getElementById('visc'),
    aoa: document.getElementById('aoa'),
    camber: document.getElementById('camber'),
    thick: document.getElementById('thick'),
    fps: document.getElementById('fps'),
    status: document.getElementById('status'),
    plotType: document.getElementById('plotType'),
    toggleBtn: document.getElementById('toggleBtn')
};

function init() {
    canvas.width = lx;
    canvas.height = ly;
    
    // Fast initialization with equilibrium distribution
    const eq = equilibrium(1.0, u0, 0.0);
    for (let i = 0; i < totalCells; i++) {
        rho[i] = 1.0;
        ux[i] = u0;
        uy[i] = 0.0;
        barrier[i] = 0;
        
        for (let d = 0; d < 9; d++) {
            f[i * 9 + d] = eq[d];
            newF[i * 9 + d] = eq[d];
        }
    }

    updateObstacle();
    lastTime = performance.now();
    
    if (running) {
        startAnimation();
    } else {
        render();
    }
}

function updateObstacle() {
    barrier.fill(0);

    // Top/Bottom Walls
    for (let x = 0; x < lx; x++) {
        barrier[x] = 1;
        barrier[x + (ly - 1) * lx] = 1;
    }

    const angle = parseFloat(ui.aoa.value) * (Math.PI / 180);
    const thickness = parseFloat(ui.thick.value);
    const camber = parseFloat(ui.camber.value);
    
    const c_x = Math.max(-0.9, Math.min(-0.1, -thickness)); 
    const c_y = Math.max(-0.4, Math.min(0.4, camber));
    const R = Math.sqrt((1 - c_x)**2 + c_y**2); 

    const centerX = lx / 3;
    const centerY = ly / 2;
    const scale = 50;

    const poly = [];
    const steps = 100; // Reduced for faster computation
    for (let s = 0; s < steps; s++) {
        const theta = (s / steps) * 2 * Math.PI;
        const zeta_x = c_x + R * Math.cos(theta);
        const zeta_y = c_y + R * Math.sin(theta);
        const denom = zeta_x*zeta_x + zeta_y*zeta_y;
        
        if (Math.abs(denom) < 1e-6) continue;
        
        let z_x = zeta_x * (1 + 1/denom);
        let z_y = zeta_y * (1 - 1/denom);

        const rot_x = z_x * Math.cos(angle) - z_y * Math.sin(angle);
        const rot_y = z_x * Math.sin(angle) + z_y * Math.cos(angle);

        poly.push({
            x: centerX + rot_x * scale,
            y: centerY - rot_y * scale
        });
    }

    if (poly.length < 3) {
        poly.push({x: centerX, y: centerY - 20}, {x: centerX + 40, y: centerY}, {x: centerX, y: centerY + 20});
    }

    // Initialize fluid inside obstacle
    const safeEq = equilibrium(1.0, 0.0, 0.0);

    // Use faster sampling for obstacle update
    for (let y = Math.max(1, Math.floor(centerY - 100)); y < Math.min(ly - 1, Math.floor(centerY + 100)); y++) {
        for (let x = Math.max(0, Math.floor(centerX - 100)); x < Math.min(lx, Math.floor(centerX + 100)); x++) {
            const i = x + y * lx;
            if (pointInPolygon(x, y, poly)) {
                barrier[i] = 1;
                ux[i] = 0.0; uy[i] = 0.0; rho[i] = 1.0;
                for(let d=0; d<9; d++) {
                    f[i*9+d] = safeEq[d];
                    newF[i*9+d] = safeEq[d];
                }
            }
        }
    }
}

function pointInPolygon(x, y, poly) {
    let inside = false;
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        
        const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / ((yj - yi) || 1) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}

function equilibrium(rho, ux, uy) {
    const eq = new Float32Array(9);
    const u2 = ux * ux + uy * uy;
    for (let i = 0; i < 9; i++) {
        const eu = ex[i] * ux + ey[i] * uy;
        eq[i] = weights[i] * rho * (1 + 3*eu + 4.5*eu*eu - 1.5*u2);
    }
    return eq;
}

function fastReset() {
    // Fast reset to equilibrium without full reinitialization
    const eq = equilibrium(1.0, u0, 0.0);
    const startTime = performance.now();
    
    for (let i = 0; i < totalCells; i++) {
        if (!barrier[i]) {
            rho[i] = 1.0;
            ux[i] = u0;
            uy[i] = 0.0;
            
            for (let d = 0; d < 9; d++) {
                f[i * 9 + d] = eq[d];
                newF[i * 9 + d] = eq[d];
            }
        }
        
        // Check timeout every 10000 cells to avoid blocking
        if (i % 10000 === 0 && performance.now() - startTime > 16) {
            // Yield to prevent blocking
            setTimeout(() => fastResetContinue(i + 1, eq, startTime), 0);
            return;
        }
    }
    
    // If we get here, we finished without interruption
    updateComplete();
}

function fastResetContinue(startIndex, eq, startTime) {
    for (let i = startIndex; i < totalCells; i++) {
        if (!barrier[i]) {
            rho[i] = 1.0;
            ux[i] = u0;
            uy[i] = 0.0;
            
            for (let d = 0; d < 9; d++) {
                f[i * 9 + d] = eq[d];
                newF[i * 9 + d] = eq[d];
            }
        }
        
        if (i % 10000 === 0 && performance.now() - startTime > 16) {
            setTimeout(() => fastResetContinue(i + 1, eq, startTime), 0);
            return;
        }
    }
    
    updateComplete();
}

function updateComplete() {
    isUpdating = false;
    loading.style.display = 'none';
    
    if (updateRequested) {
        updateRequested = false;
        handleParameterChange();
    } else if (running) {
        startAnimation();
    } else {
        render();
    }
}

function step() {
    if (!running || isUpdating) {
        return;
    }

    u0 = parseFloat(ui.speed.value);
    viscosity = parseFloat(ui.visc.value);
    const baseTau = 3.0 * viscosity + 0.5;
    const stepsPerFrame = 2; // Reduced for faster response

    for (let s = 0; s < stepsPerFrame; s++) {
        
        // 1. COLLISION & MACROSCOPIC UPDATE
        for (let y = 0; y < ly; y++) {
            for (let x = 0; x < lx; x++) {
                const i = x + y * lx;
                if (barrier[i]) continue;

                const idxBase = i * 9;
                
                let sumRho = 0, sumUx = 0, sumUy = 0;
                
                let v;
                v = f[idxBase]; sumRho += v;
                v = f[idxBase+1]; sumRho += v; sumUx += v;
                v = f[idxBase+2]; sumRho += v; sumUy += v;
                v = f[idxBase+3]; sumRho += v; sumUx -= v;
                v = f[idxBase+4]; sumRho += v; sumUy -= v;
                v = f[idxBase+5]; sumRho += v; sumUx += v; sumUy += v;
                v = f[idxBase+6]; sumRho += v; sumUx -= v; sumUy += v;
                v = f[idxBase+7]; sumRho += v; sumUx -= v; sumUy -= v;
                v = f[idxBase+8]; sumRho += v; sumUx += v; sumUy -= v;

                if (Math.abs(sumRho) < 1e-6) sumRho = 1.0;
                
                rho[i] = sumRho;
                const invRho = 1.0 / sumRho;
                let u_x = sumUx * invRho;
                let u_y = sumUy * invRho;

                const uSq = u_x*u_x + u_y*u_y;
                if (uSq > 0.15) { 
                    const scale = Math.sqrt(0.15 / uSq);
                    u_x *= scale;
                    u_y *= scale;
                }

                ux[i] = u_x;
                uy[i] = u_y;

                const u2 = u_x*u_x + u_y*u_y;

                for (let d = 0; d < 9; d++) {
                    const eu = ex[d] * u_x + ey[d] * u_y;
                    const feq = weights[d] * sumRho * (1 + 3*eu + 4.5*eu*eu - 1.5*u2);
                    f[idxBase + d] += (feq - f[idxBase + d]) / baseTau;
                    
                    if (!isFinite(f[idxBase + d]) || Math.abs(f[idxBase + d]) > 1e6) {
                        f[idxBase + d] = weights[d] * sumRho;
                    }
                }
            }
        }

        // 2. STREAMING
        newF.fill(0);

        for (let y = 0; y < ly; y++) {
            for (let x = 0; x < lx; x++) {
                const i = x + y * lx;
                if (barrier[i]) continue;

                for (let d = 0; d < 9; d++) {
                    const nextX = x + ex[d];
                    const nextY = y + ey[d];

                    if (nextX >= 0 && nextX < lx && nextY >= 0 && nextY < ly) {
                        const nextI = nextX + nextY * lx;
                        if (barrier[nextI]) {
                            newF[i * 9 + opp[d]] = f[i * 9 + d];
                        } else {
                            newF[nextI * 9 + d] = f[i * 9 + d];
                        }
                    }
                }
            }
        }

        // 3. BOUNDARIES
        for (let y = 0; y < ly; y++) {
            const iIn = y * lx;
            const iOut = (lx - 1) + y * lx;
            const iPrev = (lx - 2) + y * lx;

            if (!barrier[iIn]) {
                const eq = equilibrium(1.0, u0, 0);
                for (let d = 0; d < 9; d++) newF[iIn*9+d] = eq[d];
            }
            
            if (!barrier[iOut]) {
                for (let d = 0; d < 9; d++) newF[iOut*9+d] = newF[iPrev*9+d];
            }
        }

        let temp = f; f = newF; newF = temp;
    }
    
    if (!isFinite(rho[lx*ly/2])) {
        console.warn("NaN/Infinity Detected. Restarting.");
        init();
        return;
    }

    render();
    updateStats();
    
    if (running && !isUpdating) {
        animationId = requestAnimationFrame(step);
    }
}

function startAnimation() {
    if (animationId) {
        cancelAnimationFrame(animationId);
    }
    animationId = requestAnimationFrame(step);
}

function stopAnimation() {
    if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
    }
}

// --- RENDERING ---

let lastTime = performance.now();
let frameCount = 0;

function getSciColor(val, min, max) {
    if (!isFinite(val)) return 0xFF000000; 
    let t = (val - min) / ((max - min) || 1);
    t = t < 0 ? 0 : (t > 1 ? 1 : t);

    let r, g, b;
    if (t < 0.25) { r=0; g=4*t; b=1; }
    else if (t < 0.5) { r=0; g=1; b=1-4*(t-0.25); }
    else if (t < 0.75) { r=4*(t-0.5); g=1; b=0; }
    else { r=1; g=1-4*(t-0.75); b=0; }

    return ((255 << 24) | ((b*255)<<16) | ((g*255)<<8) | (r*255)) >>> 0;
}

function render() {
    plotType = ui.plotType.value;
    const isCurl = plotType === "curl";
    
    const minSpeed = 0;
    const maxSpeed = u0 * 2.0;
    const minCurl = -0.1;
    const maxCurl = 0.1;
    
    for (let y = 0; y < ly; y++) {
        for (let x = 0; x < lx; x++) {
            const i = x + y * lx;
            
            if (barrier[i]) {
                buf32[i] = 0xFF404040;
                continue;
            }

            let val = 0;
            if (isCurl) {
                const n = (y < ly-1) ? (x + (y+1)*lx) : i;
                const s = (y > 0) ? (x + (y-1)*lx) : i;
                const e = (x < lx-1) ? ((x+1) + y*lx) : i;
                const w = (x > 0) ? ((x-1) + y*lx) : i;
                
                val = (uy[e] - uy[w]) - (ux[n] - ux[s]);
                buf32[i] = getSciColor(val, minCurl, maxCurl);
            } else {
                val = Math.sqrt(ux[i]**2 + uy[i]**2);
                buf32[i] = getSciColor(val, minSpeed, maxSpeed);
            }
        }
    }
    ctx.putImageData(imgData, 0, 0);
}

function updateStats() {
    const now = performance.now();
    const delta = now - lastTime;
    frameCount++;
    if (delta >= 1000) {
        ui.fps.innerText = `FPS: ${(frameCount * 1000 / delta).toFixed(1)}`;
        frameCount = 0;
        lastTime = now;
    }
}

// --- FAST PARAMETER UPDATE SYSTEM ---

let updateTimeout;
let parameterChangeTimeout;

function handleParameterChange() {
    if (isUpdating) {
        updateRequested = true;
        return;
    }
    
    isUpdating = true;
    loading.style.display = 'block';
    
    // Stop current animation immediately
    stopAnimation();
    
    // Update UI values immediately
    updateUIValues();
    
    // Start fast update with timeout protection
    const updateStartTime = performance.now();
    
    // Use setTimeout to yield to browser and prevent blocking
    setTimeout(() => {
        updateObstacle();
        fastReset();
        
        // Safety timeout - if update takes more than 800ms, force completion
        setTimeout(() => {
            if (isUpdating) {
                console.warn("Update taking too long, forcing completion");
                updateComplete();
            }
        }, 800);
    }, 0);
}

function debouncedParameterChange() {
    clearTimeout(parameterChangeTimeout);
    parameterChangeTimeout = setTimeout(handleParameterChange, 50);
}

function updateUIValues() {
    document.getElementById('val-speed').innerText = parseFloat(ui.speed.value).toFixed(3);
    document.getElementById('val-visc').innerText = parseFloat(ui.visc.value).toFixed(3);
    document.getElementById('val-aoa').innerText = ui.aoa.value + "°";
    document.getElementById('val-camber').innerText = parseFloat(ui.camber.value).toFixed(2);
    document.getElementById('val-thick').innerText = parseFloat(ui.thick.value).toFixed(2);
}

// Event listeners
['speed', 'visc', 'aoa', 'camber', 'thick'].forEach(id => {
    document.getElementById(id).addEventListener('input', () => {
        updateUIValues();
        debouncedParameterChange();
    });
});

ui.plotType.addEventListener('change', () => {
    render();
});

document.getElementById('resetBtn').addEventListener('click', () => {
    stopAnimation();
    init();
});

ui.toggleBtn.addEventListener('click', () => {
    running = !running;
    ui.toggleBtn.innerText = running ? "Pause" : "Resume";
    ui.toggleBtn.classList.toggle('paused', !running);
    ui.status.innerText = running ? "RUNNING" : "PAUSED";
    
    if (running && !isUpdating) {
        startAnimation();
    } else {
        stopAnimation();
    }
});

// Start
init();

</script>
</body>
</html>
